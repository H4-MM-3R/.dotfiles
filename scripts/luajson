#!/usr/bin/env bash
# json-cli.sh - JSON encode/decode via lua-json rock (compatible with Lua 5.1+)

set -euo pipefail

if [[ $# -lt 1 ]]; then
  cat <<EOF >&2
Usage: ${0##*/} <encode|decode>

Modes:
  encode   Read a Lua literal (table, number, string, boolean) from stdin, output JSON
  decode   Read JSON from stdin, output shell-style key=value pairs
EOF
  exit 1
fi

mode=$1
shift

case "$mode" in
  encode)
    lua -e '
      -- Reads an inspect-style Lua table literal from stdin and reconstructs shared references

      -- Slurp full input (e.g. { sometable = <1>{ ... }, anothertable = <table 1> })
      local input = io.read("*all")

      -- 1) Extract definitions: any "<N>{...}" -> store in refs[N]
      local refs = {}
      local def_pat = "<(%d+)>%s*(%b{})"
      for id, body in input:gmatch(def_pat) do
        refs[tonumber(id)] = body
      end

      -- 2) Rewrite input:
      --    - replace each "<N>{...}" def with "refs[N]"
      --    - replace each "<table N>" ref with "refs[N]"
      local cleaned = input
        :gsub(def_pat, function(id, body)
          return string.format("refs[%s]", id)
        end)
        :gsub("<table%s+(%d+)>", "refs[%1]")

      -- 3) Build a chunk that seeds refs[] and returns the cleaned table literal
      local lines = {"local refs = {}"}
      for i, body in pairs(refs) do
        table.insert(lines, string.format("refs[%d] = %s", i, body))
      end
      table.insert(lines, "return " .. cleaned)
      local chunk_src = table.concat(lines, "\n")

      -- 4) Load/run using Lua 5.1+ compatible loader
      local loader = loadstring or load
      local fn, err = loader(chunk_src)
      if not fn then
        error("Failed to load reconstructed chunk:\n" .. err .. "\n\nSource:\n" .. chunk_src)
      end
      local ok, tbl = pcall(fn)
      if not ok then
        error("Runtime error while reconstructing table: " .. tbl)
      end

      -- 5) Output as JSON (requires lua-json installed) for easy consumption
      local JSON = require("JSON")
      print(JSON:encode(tbl))
    '
    ;;

  decode)
    lua -e '
      local JSON = require("JSON")
      -- read all of stdin as JSON text
      local j = io.read("*all")
      local ok, tbl_or_err = pcall(JSON.decode, j)
      if not ok then io.stderr:write("JSON decode error: ", tbl_or_err, "\n") os.exit(1) end
      local t = tbl_or_err
      for k, v in pairs(t) do
        if type(v) == "string" then
          print(k .. "=\"" .. v .. "\"")
        else
          print(k .. "=" .. tostring(v))
        end
      end
    '
    ;;

  *)
    echo "Error: unknown mode '$mode'" >&2
    echo "Usage: ${0##*/} <encode|decode>" >&2
    exit 1
    ;;
esac

